<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="UTF-8">
    <title>
      Presentation API
    </title>
    <style>
@media print {
     [data-anolis-spec]::after { content:"[" attr(data-anolis-spec) "]"; font-size:.6em; vertical-align:super; text-transform:uppercase }
    }
    </style>
    <link rel="stylesheet" type="text/css" href=
    "http://www.w3.org/StyleSheets/TR/W3C-ED">
    <style type="text/css">
/* Note formatting taken from HTML5 spec */
    .note { border-left-style: solid; border-left-width: 0.25em; background: none repeat scroll 0 0 #E9FBE9; border-color: #52E052; }
    .note em, .warning em, .note i, .warning i { font-style: normal; }
    p.note, div.note { padding: 0.5em 2em; }
    span.note { padding: 0 2em; }
    .note p:first-child { margin-top: 0; }
    .note p:last-child { margin-bottom: 0; }
    p.note:before { content: 'Note: '; font-weight: bolder;}

    .open-issue { border-left-style: solid; border-left-width: 0.25em; background: none repeat scroll 0 0 #fbfbe9; border-color: #faf9a5; }
    .open-issue em, .warning em, .open-issue i, .warning i { font-style: normal; }
    p.open-issue, div.open-issue { padding: 0.5em 2em; }
    span.open-issue { padding: 0 2em; }
    .open-issue p:first-child { margin-top: 0; }
    .open-issue p:last-child { margin-bottom: 0; }
    p.open-issue:before { content: 'Open issue: '; font-weight: bolder;}

    .non-normative { border-left-style: solid; border-left-width: 0.25em; background: none repeat scroll 0 0 #E9FBE9; border-color: #52E052; }
    p.non-normative:before { content: 'Non-normative: '; font-weight: bolder;}
    p.non-normative, div.non-normative { padding: 0.5em 2em; }


    /* Pre.idl formatting taken from HTML5 spec */
    pre.idl { border: solid thin #d3d3d3; background: #FCFCFC; color: black; padding: 0.5em 1em; position: relative; }
    pre.idl :link, pre.idl :visited { color: inherit; background: transparent; }
    pre.idl::before { content: "IDL"; font: bold small sans-serif;
    padding: 0.5em; background: white; position: absolute; top: 0;
    margin: -1px 0 0 -4em; width: 1.5em; border: thin solid;
    border-radius: 0 0 0 0.5em }

    /* .example idl formatting taken from HTML5 nightly spec */
    .example {
        display: block;
        color: #222222;
        background: #FCFCFC;
        border-left-style: solid;
        border-color: #c0c0c0;
        border-left-width: 0.25em;
        margin-left: 1em;
        padding-left: 1em;
        padding-bottom: 0.5em;
    }

    .algorithm li {
        margin-bottom: 0.5em;
    }

    .interface dd, .parameters dt {
        margin-bottom: 0.5em;
    }

    code { color: orangered; }
    .XXX { background: white; border: solid #78AB46; padding: 0.5em; margin: 1em 0; }
    table { border-collapse: collapse; border-style: hidden hidden none hidden; }
    table thead, table tbody { border-bottom: solid; }
    table td, table th { border-left: solid; border-right: solid; border-bottom: solid thin; vertical-align: top; padding: 0.2em; }
    dfn { font-weight: bolder; font-style: normal; }
    </style>
  </head>
  <body>
    <div class="head">
      <!--logo-->
      <h1>
        Presentation API
      </h1>
      <h2 class="no-num no-toc">
        W3C [LONGSTATUS] [DATE]
      </h2>
      <dl>
        <dt>
          This Version:
        </dt>
        <dd>
          <!--begin-link-->http://w3c.github.io/presentation-api/ 
          <!--end-link-->
        </dd>
        <dt>
          Latest Published Version:
        </dt>
        <dd>
          <!--begin-link-->http://www.w3.org/TR/presentation-api/ 
          <!--end-link-->
        </dd>
        <dt>
          Latest Editor's Draft:
        </dt>
        <dd>
          <!--begin-link-->http://w3c.github.io/presentation-api/ 
          <!--end-link-->
        </dd>
        <dt>
          Version History:
        </dt>
        <dd>
          <!--begin-link-->https://github.com/w3c/presentation-api/commits/ 
          <!--end-link-->
        </dd>
        <dt>
          Participate:
        </dt>
        <dd>
          Send feedback to the Working Group's mailing list <a href=
          "https://lists.w3.org/Archives/Public/public-secondscreen/">public-secondscreen@w3.org</a>,
          or <a href="https://github.com/w3c/presentation-api/issues">create or
          browse open issues</a> on GitHub. Also, you may join on the <a href=
          "irc://irc.w3.org:6665/#webscreens">WG's IRC channel</a>.
        </dd>
        <dt>
          Editor:
        </dt>
        <dd>
          <a href="mailto:dominik.rottsches@intel.com">Dominik Röttsches</a>,
          Intel
        </dd>
      </dl>
      <p class="copyright">
        <a href=
        "http://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a>
        © 2014 <a href="http://www.w3.org/"><abbr title=
        "World Wide Web Consortium">W3C</abbr></a><sup>®</sup> (<a href=
        "http://www.csail.mit.edu/"><abbr title=
        "Massachusetts Institute of Technology">MIT</abbr></a>, <a href=
        "http://www.ercim.eu/"><abbr title=
        "European Research Consortium for Informatics and Mathematics">ERCIM</abbr></a>,
        <a href="http://www.keio.ac.jp/">Keio</a>, <a href=
        "http://ev.buaa.edu.cn/">Beihang</a>), All Rights Reserved.
        <abbr title="World Wide Web Consortium">W3C</abbr> <a href=
        "http://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</a>,
        <a href=
        "http://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</a>
        and <a href=
        "http://www.w3.org/Consortium/Legal/copyright-documents">document
        use</a> rules apply.
      </p>
      <hr>
    </div>
    <h2 class="no-num no-toc">
      Abstract
    </h2>
    <p>
      This specification defines an API to enable web content to access
      external presentation-type displays and use them for presenting web
      content.
    </p>
    <h2 class="no-num no-toc" id="sotd">
      Status of This Document
    </h2>
    <p>
      <em>This section describes the status of this document at the time of its
      publication. Other documents may supersede this document. A list of
      current W3C publications and the latest revision of this technical report
      can be found in the <a href="http://www.w3.org/TR/">W3C technical reports
      index</a> at http://www.w3.org/TR/.</em>
    </p>
    <p>
      This document was published by the <a href=
      "http://www.w3.org/2014/secondscreen/">Second Screen Presentation Working
      Group</a> as an Editor's Draft. If you wish to make comments regarding
      this document, please send them to <a href=
      "mailto:public-secondscreen@w3.org">public-secondscreen@w3.org</a>
      (<a href=
      "mailto:public-secondscreen-request@w3.org?subject=subscribe">subscribe</a>,
      <a href=
      "http://lists.w3.org/Archives/Public/public-secondscreen/">archives</a>).
      All comments are welcome.
    </p>
    <p>
      Publication as an Editor's Draft does not imply endorsement by the
      <abbr title="World Wide Web Consortium">W3C</abbr> Membership. This is a
      draft document and may be updated, replaced or obsoleted by other
      documents at any time. It is inappropriate to cite this document as other
      than work in progress.
    </p>
    <p>
      This document was produced by a group operating under the <a id=
      "sotd_patent" rel="w3p:patentRules" href=
      "http://www.w3.org/Consortium/Patent-Policy-20040205/">5 February 2004
      <abbr title="World Wide Web Consortium">W3C</abbr> Patent Policy</a>.
      <abbr title="World Wide Web Consortium">W3C</abbr> maintains a <a href=
      "http://www.w3.org/2004/01/pp-impl/74168/status" rel="disclosure">public
      list of any patent disclosures</a> made in connection with the
      deliverables of the group; that page also includes instructions for
      disclosing a patent. An individual who has actual knowledge of a patent
      which the individual believes contains <a href=
      "http://www.w3.org/Consortium/Patent-Policy-20040205/#def-essential">Essential
      Claim(s)</a> must disclose the information in accordance with <a href=
      "http://www.w3.org/Consortium/Patent-Policy-20040205/#sec-Disclosure">section
      6 of the <abbr title="World Wide Web Consortium">W3C</abbr> Patent
      Policy</a>.
    </p>
    <p>
      This document is governed by the <a id="w3c_process_revision" href=
      "http://www.w3.org/2014/Process-20140801/">1 August 2014 <abbr title=
      "World Wide Web Consortium">W3C</abbr> Process Document</a>.
    </p>
    <h2 class="no-num no-toc">
      Table of Contents
    </h2><!--toc-->
    <h2>
      Introduction
    </h2><em>This section is non-normative.</em>
    <p>
      This specification aims to make secondary displays such as a projector or
      a connected TV available to the web and takes into account displays that
      are attached using wired (HDMI, DVI or similar) and wireless technologies
      (MiraCast, Chromecast, DLNA, AirPlay or similar).
    </p>
    <p>
      Devices with limited screen size lack the ability to show content to a
      larger audience, for example a group of colleagues in a conference room,
      or friends and family at home. Showing content on an external large
      display helps to improve the perceived quality and impact of the
      presented content.
    </p>
    <p>
      At its core, this specification enables an exchange of messages between a
      requesting page and a presentation page shown in the secondary display.
      How those messages are transmitted is left to the UA in order to allow
      for use of display devices that can be attached in a wide variety of
      ways. For example, when a display device is attached using HDMI or
      MiraCast, the UA on the requesting device can render the requested
      presentation page in that same UA, but instead of displaying in a window
      on that same device, it can use whatever means the operating system
      provides for using those external displays. In that case, both the
      requesting page and the presentation page run on the requesting device
      and the operating system is used to route the presentation display output
      to the other display device. The second display device doesn't need to
      know anything about this spec or that the content involves HTML5.
    </p>
    <p>
      Alternately, some types of external displays may be able to render HTML5
      themselves and may have defined their own way to send messages to that
      content. In that case, the UA on the requesting device would not need to
      render the presentation page itself. Instead, the UA could act as a proxy
      translating the request to show a page and the messages into the form
      understood by the display device.
    </p>
    <p>
      This way of attaching to displays could be enhanced in the future through
      definition of a standard protocol for delivering these types of messages
      that display devices could choose to implement.
    </p>
    <p>
      The API defined here is intended be used with UAs that attach to display
      devices through any of the above means.
    </p>
    <h3 id="use-cases">
      Use cases
    </h3>
    <h4>
      Presentations
    </h4>
    <p>
      A user is preparing a set of slides for a talk. Using a web based
      service, she is editing her slides and speaker notes on the primary
      screen, while the secondary larger screen shows a preview of the current
      slide. When the slides are done, her mobile phone allows her to access
      them from an online service while on the go. Coming to the conference,
      using wireless display technology, she would like to present her slides
      on the stage screen from her mobile phone. The phone's touch screen helps
      her to navigate slides and presents a slide preview, while the projector
      shows her slides to the audience.
    </p>
    <p>
      <b>Requirements:</b> R1, R3, R4, R5, R7
    </p>
    <h4>
      <a id="video-sharing">Video and image sharing</a>
    </h4>
    <p>
      Using an online video or image sharing service, a user would like to show
      memorable moments to her friends. Using a device with a small screen, it
      is impossible to show the content to a large group of people. Connecting
      an external TV screen or projector to her device - with a cable or
      wirelessly - the online sharing service now makes use of the connected
      display, allowing a wider audience to enjoy the content.
    </p>
    <p>
      The web page shows UI elements that allow the user to trigger displaying
      content on the secondary display (e.g a "send to second screen" ) only if
      there is at least one secondary screen available.
    </p>
    <p>
      <b>Requirements:</b> R1, R3, R4, R5, R7
    </p>
    <h4>
      Gaming
    </h4>
    <p>
      Splitting the gaming experience into a near screen controller and a large
      screen visual experience, new gaming experiences can be created.
      Accessing the local display on the small screen device and an external
      larger display allows for richer web-based gaming experiences.
    </p>
    <p>
      <b>Requirements:</b> R1, R3, R4, R5, R7
    </p>
    <h4>
      Media flinging to multiple screens
    </h4>Alice enters a video sharing site using a browser on her tablet. Next,
    Alice picks her favorite video from the site, and the video starts to play
    on her tablet. While the video is playing Alice clicks a button "Share on
    different screen". The browser provides a user interface that lists all the
    screens Alice has around her home, asking her to select one. The screens
    are identified by names that are familiar to Alice. Alice picks one screen
    from the list, "Alice's big TV", and the video playback continues
    seamlessly on the selected screen. Next she decides to switch the playback
    to a different screen. She clicks the same button "Share on different
    screen" provided by the site, and the browser presents the user interface
    that lists all the screens. Alice picks another screen from the list,
    "Alice's kitchen TV", and the playback resumes on that screen. Video site
    also provides a feature to see the action (Alice is watching a soccer game)
    from different angle. Alice clicks a button "Select screen for additional
    angle", and the browser asks Alice similarly to select the screen to be
    used for playback. Alice picks "Alice's Projector" and the soccer game is
    shown on the projector from a different angle, in parallel to the content
    being played back on "Alice's kitchen TV".
    <p>
      <b>Requirements:</b> R1, R3, R4, R5, R6, R7
    </p>
    <h2>
      Requirements
    </h2>
    <h3>
      Functional requirements
    </h3>
    <ul>
      <li>
        <b>Discovery / Availability</b>
        <ul>
          <li>R1: The UA must provide a way to find out whether at least one
          secondary screen is available.
          </li>
        </ul>
      </li>
    </ul>
    <p class="note">
      Multi-Screen enumeration and named identification removed, after
      discussion on the mailing list, cmp. <a rel="nofollow" class=
      "external free" href=
      "http://lists.w3.org/Archives/Public/public-webscreens/2014Feb/0021.html">
      http://lists.w3.org/Archives/Public/public-webscreens/2014Feb/0021.html</a>&nbsp;:
    </p>
    <ul>
      <li>
        <b>Launching Presentation</b>
        <ul>
          <li>R3: The UA must provide a means of start sending content to the
          secondary screen.
          </li>
        </ul>
      </li>
      <li>
        <b>Resuming Presentation</b>
        <ul>
          <li>R4: The UA must be able to resume an existing session with
          content being displayed on the secondary screen.
          </li>
        </ul>
      </li>
      <li>
        <b>Communication</b>
        <ul>
          <li>R5: The UA must enable exchanging data between the primary and
          the secondary screen in order to have a control channel between the
          primary and secondary page.
          </li>
          <li>R6: The UA must not make assumptions about the the execution
          locality of the user agent of the remote page it communicates with
          (i.e. the secondary page might run on a remote user agent and thus
          the link between the two pages' UA must be loosely coupled).
          </li>
        </ul>
      </li>
    </ul>
    <ul>
      <li>
        <b>Signaling Disconnection</b>
        <ul>
          <li>R7: The UA must signal disconnection from the presentation page
          to the primary page and vice versa.
          </li>
        </ul>
      </li>
    </ul>
    <h3>
      <span id="non-functional_requirements">Non-functional requirements</span>
    </h3>
    <ul>
      <li>
        <b>Power Saving Friendly</b>
        <ul>
          <li>All API design decisions must be analyzed from a power efficiency
          point of view. Especially when using wireless display technologies or
          querying availability over a radio channel, care needs to be taken to
          design the API in a way that does not pose obstacles to using radio
          resources in an efficient way. For example, powering up the wireless
          display detection only when needed.
          </li>
        </ul>
      </li>
    </ul>
    <h2>
      Conformance
    </h2>
    <p>
      All diagrams, examples, and notes in this specification are
      non-normative, as are all sections explicitly marked non-normative.
      Everything else in this specification is normative.
    </p>
    <p>
      The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
      "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
      "OPTIONAL" in this document are to be interpreted as described in RFC
      2119. For readability, these words do not appear in all uppercase letters
      in this specification. <span data-anolis-ref="">RFC2119</span>
    </p>
    <p>
      Requirements phrased in the imperative as part of algorithms (such as
      "strip any leading space characters" or "return false and terminate these
      steps") are to be interpreted with the meaning of the key word ("must",
      "should", "may", etc.) used in introducing the algorithm.
    </p>
    <p>
      Conformance requirements phrased as algorithms or specific steps may be
      implemented in any manner, so long as the end result is equivalent. (In
      particular, the algorithms defined in this specification are intended to
      be easy to follow, and not intended to be performant.)
    </p>
    <h2>
      Terminology
    </h2>
    <p>
      The terms <span data-anolis-spec="w3c-html">browsing context</span>,
      <span data-anolis-spec="w3c-html">event handlers</span>, <span title=
      "event handler event type" data-anolis-spec="w3c-html">event handler
      event types</span>, <span data-anolis-spec="w3c-html" title=
      "concept-event-fire">firing an event</span>, <span data-anolis-spec=
      "w3c-html">navigate</span>, <span data-anolis-spec="w3c-html" title=
      "queue a task">queing a task</span> are defined in <span data-anolis-ref=
      "">HTML5</span>.
    </p>
    <p>
      The term <span data-anolis-spec="es6" title=
      "promise-objects">Promise</span> is defined in <span data-anolis-ref=
      "">ES6</span>. The terms <span data-anolis-spec="promguide" title=
      "resolve-reject">resolving a Promise, and rejecting a Promise</span> are
      used as explained in <span data-anolis-ref="">PROMGUIDE</span>.
    </p>
    <p>
      The term <span data-anolis-spec="url">URL</span> is defined in the WHATWG
      URL standard: <span data-anolis-ref="url">URL</span>.
    </p>
    <p>
      This document provides interface definitions using the
      <span data-anolis-ref="">WEBIDL</span> standard.
    </p>
    <h2>
      Example
    </h2>
    <p>
      Running in a compliant user agent, code for presenting a page
      <code>http://example.org/presentation.html</code> on the presentation
      display looks as follows:
    </p>
    <pre class="example">
/* controller.html */

&lt;button disabled id=show&gt;Show&lt;/button&gt;
&lt;button disabled id=stop&gt;Stop&lt;/button&gt;

&lt;script&gt;

var presentation = navigator.presentation,
    showButton = document.getElementById('show'),
    stopButton = document.getElementById('stop');

var session = null;
var screenAvailable = false;
var presentationUrl = 'http://example.org/presentation.html';
var presentationId = localStorage['presentationId'] ||
    new String((Math.random() * 10000).toFixed(0));

// Join an existing presentation if one exists.
presentation.joinSession(presentationUrl, presentationId).then(
    function(existingSession) {
      setSession(existingSession);
      updateButtons();
    },
    function() {
      // No session to join.
    });

presentation.onavailablechange = function(e) {
  screenAvailable = e.available;
  updateButtons();
};

function updateButtons() {
  stopButton.disabled = !session;
  stopButton.onClick = session ? stopPresent : null;
  showButton.disabled = !screenAvailable;
  showButton.onclick = screenAvailable ? startPresent : null;
};

function startPresent() {
  presentation.startSession(presentationUrl, presentationId).then(
      function(newSession) {
        setSession(newSession);
        updateButtons();
      },
      function() {
        // User cancelled, etc.
      });
};

function stopPresent() {
  if (!session) return;
  session.close();
  delete localStorage['presentationId'];
};

function setSession(theSession) {
  // NOTE: We could instead close the current session.
  if (session) return;
  session = theSession;
  localStorage['presentationId'] = session.id;
  session.onstatechange = function() {
    switch (session.state) {
      case 'connected':
        session.postMessage(/*...*/);
        session.onmessage = function() { /*...*/ };
        break;
      case 'disconnected':
        console.log('Disconnected.');
        break;
    }
  };
}
&lt;/script&gt;
</pre>
    <p class="open-issue">
      We could simplify the example, and perhaps remove UI button state
      management for the sake of clarity.
    </p>
    <p>
      The availability monitoring for secondary screens begins when the page
      adds an event listener for the <code>availablechange</code> event on the
      <code>navigator.presentation</code> object. If there are already
      available screens when the page adds the first event listener for the
      event, the UA synthesizes a single <code>availablechange</code> event to
      signal the availability.
    </p>
    <p class="open-issue">
      Do we want to fire an event immediately after the page registers for it?
      What's a best practice method for asynchronous notifications of this
      kind? See below in the <a href="#open-questions">Open questions</a>
      section.
    </p>
    <p class="open-issue">
      It is an open issue whether to provide filter information as part of the
      request for notification of available screens. This could be useful when
      a particular application or capability is needed in order to display the
      contents of a presentation. One possible approach to this could be to
      provide the URL for the presentation and / or required options as part of
      the request for notification of available screens. If this was supported,
      only screens that satisfied the filter would trigger a notification.
    </p>
    <h4>
      Starting new presentations or manually connecting to existing
      presentations
    </h4>
    <p>
      The "Show" button's state (initially disabled) informs the user of the
      availability of secondary screen(s), and the button's state is updated if
      the availability changes. (The rationale of putting the actual boolean
      information into a property of the event <code>e.available</code> is to
      allow the implementation to optimize power consumption for network
      discovery of remote wireless screens. If this information was provided in
      a globally accessible flag, the network discovery could never be
      suspended for keeping the flag up to date.)
    </p>
    <p>
      Clicking the "Show" button calls
      <code>navigator.presentation.startSession()</code>, which causes the user
      agent to request from the user a screen to show the presentation. The
      <code>url</code> argument indicates the content to be presented. The
      <code>presentationId</code> argument (optional) allows the page to
      identify this presentation instance, and control which other pages may
      connect to it by setting a hard-to-guess id.
    </p>
    <p class="open-issue">
      As previously discussed on the mailing list - we can add convenience here
      by default-generating an ID.
    </p>
    <p>
      If the user selects a screen with an existing presentation showing the
      same <code>url</code> under the same <code>presentationId</code>, the
      opener page is connected to that existing presentation. If the user
      selects a screen without an existing presentation, or a screen presenting
      a different <code>url</code> or <code>presentationId</code>, the UA
      connects to the selected screen, brings up a new presentation window on
      it, and starts to show the content denoted by the <code>url</code>
      argument. The UA then connects the opener page to this new presentation
      and allows the opener page to exchange messages with it.
    </p>
    <p>
      <code>navigator.presentation.startSession(url, presentationId)</code>
      returns a <code>Promise</code> to the opener page. When the user selects
      a screen, the presentation page is shown and a communication channel has
      been established the <code>Promise</code> resolves to a
      <code>PresentationSession</code> object, which acts as a handle to the
      presentation for communication and state handling. Initially, the state
      of the <code>PresentationSession</code> is <code>"connected"</code>. At
      this point, the opener page can communicate with the presentation page
      using the session's <code>postMessage()</code> to send messages and its
      <code>onmessage</code> event handler to receive messages. The
      presentation page will also have access to
      <code>PresentationSession</code> that it can use to send and receive
      messages with the opener page (see <a href=
      "#usage-on-remote-screen">Usage on remote screen</a>).
    </p>
    <p>
      If the user cancels screen selection, the <code>Promise</code> returned
      by <code>startSession(url, presentationId)</code> remains unresolved.
    </p>
    <p>
      While there is a pending call to <code>startSession</code> asking the
      user to select a screen (that the user has not yet accepted or canceled),
      the browser may choose to reject subsequent calls to
      <code>startSession</code> from the same page, by returning a
      <code>Promise</code> that never resolves. This will prevent the browser
      from needing to 'queue up' requests to present to the user.
    </p>
    <h4>
      Automatically reconnecting to existing presentations
    </h4>
    <p>
      The opener page may wish to reconnect to an existing presentation without
      prompting the user to select a screen. For example, the site could allow
      media items from different pages to be shown on the same presentation
      page, and does not want to prompt the user on each page to reconnect to
      that presentation. To reconnect automatically, the page may call
      <code>joinSession(url, presentationId)</code>, which returns a
      <code>Promise</code> that resolves to an existing
      <code>PresentationSession</code> if one exists that is presenting the
      same <code>url</code> with the same <code>presentationId</code> as was
      passed originally into <code>startSession</code>. The requesting page can
      then communicate with the presentation as if the user had manually
      connected to it via <code>startSession</code>.
    </p>
    <p>
      At the time <code>joinSession(url, presentationId)</code> is called, if
      the browser is not aware of any <code>PresentationSession</code> with a
      matching <code>url</code> and <code>presentationId</code>, the
      <code>Promise</code> should remain unresolved. The browser may become
      aware of such a session at a later time (for example, by switching to a
      WiFi network that has a screen showing that URL). In this case, the
      browser may resolve the Promise to allow the page to connect to the
      running session.
    </p>
    <p class="open-issue">
      Do we want to keep the Promise in pending state?
    </p>
    <p>
      If the browser knows of multiple matching sessions, it should connect the
      page to the session that was most recently connected to; if that cannot
      be determined by the browser (for example, if the matching sessions have
      never been connected), then the <code>Promise</code> should remain
      unresolved.
    </p>
    <p>
      If the page calls <code>startSession(url, presentationId)</code> and
      there is a pending <code>Promise</code> from a call to
      <code>joinSession(url, presentationId)</code> (with the same
      <code>url</code> and <code>presentationId</code>, and the user selects a
      screen in response to <code>startSession</code>, then the
      <code>Promise</code> from <code>startSession</code> will be resolved and
      the <code>Promise</code> from <code>joinSession</code> will not.
    </p>
    <h4>
      Open questions
    </h4>
    <p class="open-issue">
      Do we need to insert into the description an additional permission prompt
      to grant the page access to the "one ore more screens are available"
      Information?
    </p>
    <p class="open-issue">
      If there are already connected screens when the page subscribes to the
      <code>onavailablechange</code> event, we can handle this in two ways: We
      can synthesize one initial event to notify the page about available
      screens as soon as the first event handler is installed (as described).
      Or we can add another message like
      <code>navigator.presentation.getAvailable(function(available) { }
      );</code> to notify the page about available screens using this one-time
      asynchronous getter. Which way should we go?
    </p>
    <p class="open-issue">
      Do we need an additional state like resumed in order to identify resumed
      session? It seems that this could be handled on the page level. The
      opener page could ask the presentation page whether it is
      <code>"new"</code> or <code>"resumed"</code>.
    </p>
    <h3>
      Usage on remote screen
    </h3>
    <p>
      For addressing the requirement of communication between originating page
      and presentation page/screen, the presenting page can now use the same
      <code>session</code> object. It accesses this object through the
      <code>navigator.presentation.session</code> property, which is only
      non-<code>null</code> for the page on the presentation screen.
    </p>
    <pre class="example">
if (navigator.presentation.session) {
  var session = navigator.presentation.session;
  // Communicate with opener page.
  session.postMessage(/*...*/);
  session.onmessage = function() {/*...*/};

  session.onstatechange = function() {
    switch (this.state) {
      case "disconnected":
        // Handle disconnection from opener page.
    }
  };
};
</pre>
    <p>
      When the content denoted by the <code>url</code> argument in the
      <code>startSession()</code> example above is loaded, the page on the
      presentation screen will have its
      <code>navigator.presentation.session</code> property set to the session.
      This session is a similar object as in the first example. Here, its
      initial state is <code>"connected"</code>, which means we can use it to
      communicate with the opener page using <code>postMessage()</code> and
      <code>onmessage</code>.
    </p>
    <p>
      The presentation page can also monitor the connection state by listening
      for <code>statechange</code> events. When the state changes to
      <code>"disconnected"</code> the page is made aware of the fact that
      communication with the opener page was lost, but it can continue to
      display the current content. The communication can be re-established when
      a <code>statechange</code> event fires with a new state of
      <code>"connected"</code>.
    </p>
    <p class="open-issue">
      Since we permit multiple opener pages to connect the same presentation
      page, we need to define how connection and disconnection of these pages
      is communicated to the presentation page (if at all).
    </p>
    <h2>
      API
    </h2>
    <h3>
      Common Idioms
    </h3>
    <p>
      A <dfn>presentation display</dfn> refers to an external screen available
      to the user agent via an implementation specific connection technology.
    </p>
    <p>
      A <dfn title="concept-presentation">presentation</dfn>, in the context of
      this specification, is an active connection between a user agent and a
      <span>presentation display</span> with the intent of displaying web
      content on the latter.
    </p>
    <p>
      A <dfn title="concept-presentation-session">presentation session</dfn> is
      an object refering to the relationship between an <span>opening browsing
      context</span> and a <span>presentation display</span> with a
      <dfn>presentation session state</dfn> and a <dfn>presentation session
      identifier</dfn> to distinguish a set of <span title=
      "concept-presentation-session">presentation sessions</span>.
    </p>
    <p>
      An <dfn>opening browsing context</dfn> is a <span data-anolis-spec=
      "w3c-html">browsing context</span> from which calls are made to
      <span>startSession</span>, <span>joinSession</span>, in other words from
      which <span title="concept-presentation-session">presentation
      sessions</span> are initiated.
    </p>
    <h3>
      Interface <code>PresentationSession</code>
    </h3>
    <p>
      Each <span title="concept-presentation-session">presentation
      session</span> is represented by a <code>PresentationSession</code>
      object.
    </p>
    <pre class="idl">
enum <dfn>PresentationSessionState</dfn> { "connected", "disconnected" /*, "resumed" */ };

interface <dfn>PresentationSession</dfn> : EventTarget {
  readonly DOMString? <span>id</span>;
  readonly attribute <span>PresentationSessionState</span> <span>state</span>;
  void <span>postMessage</span>(DOMString message);
  void <span>close</span>();
  attribute <span data-anolis-spec=
"w3c-html">EventHandler</span> <span>onmessage</span>;
  attribute <span data-anolis-spec=
"w3c-html">EventHandler</span> <span>onstatechange</span>;
};
</pre>
    <p>
      The <dfn><code>id</code></dfn> attribute holds the alphanumeric
      <span>presentation session identifier</span>.
    </p>
    <p>
      The <dfn><code>state</code></dfn> attribute represents the
      <span>presentation session</span>'s current state. It can take one of the
      values of <span><code>PresentationSessionState</code></span> depending on
      connection state.
    </p>
    <p>
      When the <dfn><code>postMessage</code></dfn>() method is called on a
      <code>PresentationSession</code> object with a <code>message</code>, the
      user agent must run the algorithm to <span title=
      "algorithm-post-message">post a message through a
      <span><code>PresentationSession</code></span></span>.
    </p>
    <p>
      When the <dfn><code>close</code></dfn>() method is called on a
      <code>PresentationSession</code> <em>S</em>, the user agent must run the
      algorithm to <span title="close-algorithm">close a presentation
      session</span>.
    </p>
    <h4>
      Posting a message through <code>PresentationSession</code>
    </h4>
    <p>
      When the user agent is to <dfn title="algorithm-post-message">post a
      message through a <code>PresentationSession</code> S</dfn>, it mus run
      the following steps:
    </p>
    <p class="open-issue">
      Needs algorithm for send message and more fine-grained definition of data
      types for sending. Candidates, similar interfaces, are found in the
      <a href=
      "https://html.spec.whatwg.org/multipage/comms.html#the-messageevent-interfaces">
      WHATWG HTML spec's <code>MessageEvent</code> section</a>, or the <a href=
      "http://w3c.github.io/webrtc-pc/#rtcdatachannel">WebRTC's spec
      <code>RPCDataChannel</code>.</a>
    </p>
    <h4>
      Closing a <code>PresentationSession</code>
    </h4>
    <p>
      When the user agent is to <dfn title="close-algorithm">close a
      presentation session S</dfn>, it must run the following steps:
    </p>
    <ol>
      <li>If <em>S.state</em> is not <code>connected</code>, then:
        <ol>
          <li>Abort these steps.
          </li>
        </ol>
      </li>
      <li>Set <em>S.state</em> to <code>disconnected</code>.
      </li>
      <li>Let <em>D</em> be the set of presentations known by the user agent.
      </li>
      <li>
        <span data-anolis-spec="w3c-html">Queue a task</span> <em>T</em> to run
        the following steps in order:
        <ol>
          <li>For each presentation <em>(U, I, S')</em> in <em>D</em>,
            <ol>
              <li>Let <em>u</em> equal <em>U</em>, <em>i</em> equal <em>I</em>,
              and <em>s</em> equal <em>S'</em>.
              </li>
              <li>If <em>u</em> is equal to <em>S.url</em> and <em>i</em> is
              equal to <em>S.id</em>, run the following steps:
                <ol>
                  <li>
                    <span data-anolis-spec="w3c-html">Queue a task</span> to
                    <span data-anolis-spec="w3c-html" title=
                    "concept-event-fire">fire an event</span> named
                    <code>statechange</code> at <em>s.onstatechange</em>.
                  </li>
                </ol>
              </li>
            </ol>
          </li>
        </ol>
      </li>
    </ol>
    <h4>
      Event Handlers
    </h4>
    <p>
      The following are the event handlers (and their corresponding event
      handler event types) that must be supported, as event handler IDL
      attributes, by objects implementing the <code>PresentationSession</code>
      interface:
    </p>
    <table>
      <thead>
        <tr>
          <th>
            Event handler
          </th>
          <th>
            Event handler event type
          </th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>
            <dfn><code>onmessage</code></dfn>
          </td>
          <td>
            <code>message</code>
          </td>
        </tr>
        <tr>
          <td>
            <dfn><code>onstatechange</code></dfn>
          </td>
          <td>
            <code>statechange</code>
          </td>
        </tr>
      </tbody>
    </table>
    <h3>
      Interface <code>NavigatorPresentation</code>
    </h3>
    <pre class="idl">
partial interface <span data-anolis-spec="w3c-html">Navigator</span> {
  readonly attribute <span>NavigatorPresentation</span> <span>presentation</span>;
};
</pre>
    <p>
      The <dfn><code>presentation</code></dfn> attribute is used to retrieve an
      instance of the <code>NavigatorPresentation</code> interface, the main
      interface of Presentation API.
    </p>
    <pre class="idl">
interface <dfn>NavigatorPresentation</dfn> : EventTarget {
  readonly attribute <span>PresentationSession</span>? <span>session</span>;
  Promise&lt;<span>PresentationSession</span>&gt; <span>startSession</span>(DOMString url, DOMString? presentationId);
  Promise&lt;<span>PresentationSession</span>&gt; <span>joinSession</span>(DOMString url, DOMString? presentationId);
  attribute <span data-anolis-spec=
"w3c-html">EventHandler</span> <span>onavailablechange</span>;
};
</pre>
    <p class="open-issue">
      <i>(drott)</i> What would be a good definition of the
      <code>session</code> attribute? Do we want to keep it? It's somewhat hard
      to define, when it should contain a value, and when it should be empty -
      and it's not compatible with multiple calls to startSession, for example.
    </p>
    <h4>
      Starting a presentation session
    </h4>
    <p>
      When <code><dfn>startSession</dfn>(presentationUrl,
      presentationId)</code> is called, the user agent must run the following
      steps:
    </p>
    <dl>
      <dt>
        Input
      </dt>
      <dd>
        <code>presentationUrl</code>, the <span data-anolis-spec=
        "url">URL</span> of the document to be presented
      </dd>
      <dd>
        <code>presentationId</code>, an optional identifier for the
        presentation
      </dd>
      <dt>
        Output
      </dt>
      <dd>
        <em>P</em>, a <span data-anolis-spec="es6" title=
        "promise-objects">Promise</span>
      </dd>
    </dl>
    <ol>
      <li>Let <em>P</em> be a new <span data-anolis-spec="es6" title=
      "promise-objects">Promise</span>.
      </li>
      <li>Return <em>P</em>.
      </li>
      <li>If the user agent does not <span>monitor presentation display
      availability</span>, run the following steps:
        <ol>
          <li>
            <span>Monitor presentation display availability</span>.
          </li>
          <li>Wait until the algorithm completes.
          </li>
        </ol>
      </li>
      <li>If the <a href="#availabledisplays">availableDisplays</a> list is
      empty, then:
        <ol>
          <li>
            <span data-anolis-spec="promguide" title=
            "resolve-reject">Reject</span> <em>P</em> with a
            "NoScreensAvailable" exception.
          </li>
          <li>Abort all remaining steps.
          </li>
        </ol>
      </li>
      <li>Queue a task <em>T</em> to request user permission for the use of a
      <span data-anolis-ref="presentation">presentation display</span> and
      selection of one presentation display.
        <ol>
          <li>If <em>T</em> completes with the user <em>granting
          permission</em> to use a screen, run the following steps:
            <ol>
              <li>If <code>presentationId</code> is not <em>undefined</em>,
              assign <em>I</em> to that that <code>presentationId</code>.
              </li>
              <li>If <code>presentationId</code> is <code>undefined</code>, let
              <em>I</em> be a random alphanumeric value of at least 16
              characters drawn from the characters <code>[A-Za-z0-9]</code>.
              </li>
              <li>Create a new <code>PresentationSession</code> <em>S</em>.
              </li>
              <li>Set <code>S.url</code> to <code>presentationUrl</code>, set
              <code>S.id</code> to <em>I</em>, and set <code>S.state</code> to
              <code>disconnected</code>.
              </li>
              <li>
                <span data-anolis-spec="w3c-html">Queue a task</span>
                <em>C</em> to create a new <span data-anolis-spec=
                "w3c-html">browsing context</span> on the user-selected
                <a href="presentation-display">presentation display</a> and
                <span data-anolis-spec="w3c-html">navigate</span> to
                <code>presentationUrl</code> in it.
                <ol>
                  <li>If <em>C</em> completes successfully, run the following
                  steps:
                    <ol>
                      <li>Add <em>(S.url, S.id, S)</em> to <em>D</em>.
                      </li>
                      <li>
                        <span data-anolis-spec="promguide" title=
                        "resolve-reject">Resolve</span> <em>P</em> with
                        <em>S</em>.
                      </li>
                      <li>
                        <span>Establish a presentation connection</span> with
                        <em>S</em>.
                      </li>
                    </ol>
                  </li>
                  <li>If <em>C</em> fails, run the following steps:
                    <ol>
                      <li>
                        <span data-anolis-spec="promguide" title=
                        "resolve-reject">Reject</span> P with a "failed"
                        exception.
                      </li>
                    </ol>
                  </li>
                </ol>
              </li>
            </ol>
          </li>
          <li>If <em>T</em> completes with the user <em>denying
          permission</em>, run the following steps:
            <ol>
              <li>
                <span data-anolis-spec="promguide" title=
                "resolve-reject">Reject</span> <em>P</em> with a
                "PermissionDenied" exception.
              </li>
            </ol>
          </li>
        </ol>
      </li>
    </ol>
    <p class="note">
      The details of implementing the permission request and display selection
      are left to the user agent; for example it may show the user a dialog and
      allow the user to select an available screen (granting permission), or
      cancel the selection (denying permission).
    </p>
    <p class="open-issue">
      Do we want to distinguish the permission-denied outcome from the
      no-screens-available outcome? Developers would be able to infer it anyway
      from <code>onavailablechange</code>.
    </p>
    <h4>
      Joining a presentation session
    </h4>
    <p>
      When <code><dfn>joinSession</dfn>(presentationUrl, presentationId)</code>
      is called, the user agent must run the following steps:
    </p>
    <dl>
      <dt>
        Input
      </dt>
      <dd>
        <code>presentationUrl</code>, the <span data-anolis-spec=
        "url">URL</span> of the document being presented
      </dd>
      <dd>
        <code>presentationId</code>, the identifier for the presentation
      </dd>
      <dt>
        Output
      </dt>
      <dd>
        <em>P</em>, a <span data-anolis-spec="es6" title=
        "promise-objects">Promise</span>
      </dd>
    </dl>
    <ol>
      <li>Let <em>P</em> be a new <span data-anolis-spec="es6" title=
      "promise-objects">Promise</span>.
      </li>
      <li>Return <em>P</em>.
      </li>
      <li>Let <em>D</em> be the set of presentations known by the user agent.
      </li>
      <li>
        <span data-anolis-spec="w3c-html">Queue a task</span> <em>T</em> to run
        the following steps in order:
        <ol>
          <li>For each presentation <em>(U, I, S)</em> in <em>D</em>,
            <ol>
              <li>Let <em>u</em> equal <em>U</em>, <em>i</em> equal <em>I</em>,
              and <em>s</em> equal <em>S</em>.
              </li>
              <li>If <em>u</em> is equal to <code>presentationUrl</code> and
              <em>i</em> is equal to <code>presentationId</code>, run the
              following steps:
                <ol>
                  <li>
                    <span data-anolis-spec="promguide" title=
                    "resolve-reject">Resolve</span> <em>P</em> with <em>S</em>.
                  </li>
                  <li>
                    <span>Establish a presentation connection</span> with
                    <em>S</em>.
                  </li>
                  <li>Abort the remaining steps of <em>T</em>.
                  </li>
                </ol>
              </li>
            </ol>
          </li>
          <li>
            <span data-anolis-spec="promguide" title=
            "resolve-reject">Reject</span> <em>P</em> with a
            "NoPresentationFound" exception.
          </li>
        </ol>
      </li>
    </ol>
    <p class="open-issue">
      If no matching presentation is found, we could leave the Promise pending
      in case a matching presentation is started in the future.
    </p>
    <p>
      <span>The following are the event handlers (and their corresponding event
      handler event types) that must be supported, as event handler IDL
      attributes, by objects implementing the <code>PresentationSession</code>
      interface:</span>
    </p>
    <table>
      <thead>
        <tr>
          <th>
            Event handler
          </th>
          <th>
            Event handler event type
          </th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>
            <dfn><code>onavailablechange</code></dfn>
          </td>
          <td>
            <code>availablechange</code>
          </td>
        </tr>
      </tbody>
    </table>
    <h4>
      Establishing a presentation connection
    </h4>
    <p class="XXX">
      When the user agent is to <dfn>establish a presentation connection</dfn>
      using a <span>presentation session</span> <em>S</em>, it must run the
      following steps:
    </p>
    <ol>
      <li>If <em>S.state</em> is <code>connected</code>, then:
        <ol>
          <li>Abort all remaining steps.
          </li>
        </ol>
      </li>
      <li>
        <span data-anolis-spec="w3c-html">Queue a task</span> <em>T</em> to
        connect <em>S</em> to the document that is presenting <em>S.url</em>.
      </li>
      <li>If <em>T</em> completes successfully, run the following steps:
        <ol>
          <li>Set <em>S.state</em> to <code>connected.</code>
          </li>
          <li>Let <em>D</em> be the set of presentations known by the user
          agent.
          </li>
          <li>Queue a task <em>T</em> to run the following steps in order:
            <ol>
              <li>For each presentation <em>(U, I, S')</em> in <em>D</em>,
                <ol>
                  <li>Let <em>u</em> equal <em>U</em>, <em>i</em> equal
                  <em>I</em>, and <em>s</em> equal <em>S'</em>.
                  </li>
                  <li>If <em>u</em> is equal to <em>S.url</em> and <em>i</em>
                  is equal to <em>S.id</em>, run the following steps:
                    <ol>
                      <li>
                        <span data-anolis-spec="w3c-html">Queue a task</span>
                        to <span data-anolis-spec="w3c-html" title=
                        "concept-event-fire">fire an event</span> named
                        <code>statechange</code> at <em>s.onstatechange</em>.
                      </li>
                    </ol>
                  </li>
                </ol>
              </li>
            </ol>
          </li>
        </ol>
      </li>
    </ol>
    <p class="note">
      The mechanism that is used to present on the remote display and connect
      the opening document with the presented document is an implementation
      choice of the user agent. The connection must provide a two-way messaging
      abstraction capable of carrying <code>DOMString</code> payloads in a
      reliable and in-order fashion as described in the <em>Send Message</em>
      and <em>Receive Message</em> steps below.
    </p>
    <p class="note">
      If <em>T</em> does not complete successfully, the user agent may choose
      to re-execute the Presentation Connection algorithm at a later time.
    </p>
    <p class="open-issue">
      Do we want to notify the caller of a failure to connect, i.e. with an
      "error" onstatechange?
    </p>
    <p class="open-issue">
      Do we want to pass the new state as a property of the statechange event?
    </p>
    <p class="open-issue">
      Need to further specify the semantics of the messaging channel (using
      WebSockets or MessagePort as a reference).
    </p>
    <h3>
      <span>Interface <code>AvailableChangeEvent</code></span>
    </h3>
    <pre class="idl">
<span>[Constructor(DOMString type, optional <span>AvailableChangeEventInit</span> eventInitDict)]
interface <dfn>AvailableChangeEvent</dfn> : Event {
  readonly attribute boolean available;
};

dictionary <dfn>AvailableChangeEventInit</dfn> : EventInit {
  boolean available;
};
</span>
</pre>
    <p>
      An event named <code>availablechange</code> is fired during the execution
      of the <span>monitoring presentation display availability</span>
      algorithm when the <dfn>presentation display availability</dfn> changes.
      It is fired at the <span><code>PresentationSession</code></span> object,
      using the <code>AvailableChangeEvent</code> interface, with the
      <code>available</code> attribute set to the boolean value that the
      algorithm determined.
    </p>
    <h4>
      Monitoring presentation display availability
    </h4>
    <p class="XXX">
      Each <code>Document</code> object must have a <dfn>list of available
      presentation displays</dfn>. Each display in this list is identified by a
      tuple (U, I, S) as follows:
    </p>
    <p>
      Let <em>D</em> be the set of presentations that are currently known to
      the user agent (regardles of their state). <em>D</em> is represented as a
      set of tuples <em>(U, I, S)</em> where <em>U</em> is the URL that is
      being presented; <em>I</em> is an alphanumeric identifier for the
      presentation; and <em>S</em> is the user agent's
      <code>PresentationSession</code> for the presentation. <em>U</em> and
      <em>I</em> together uniquely identify the
      <code>PresentationSession</code> of the corresponding presentation.
    </p>
    <p class="XXX">
      When the user agent is to <dfn>update the list of available presentation
      displays</dfn>, it must run the following steps:
    </p>
    <ol>
      <li>Let <a id="availabledisplays"><em>availableDisplays</em></a> be the
      <span>list of available presentation displays</span> that are currently
      known to the user agent.
      </li>
    </ol>
    <p class="XXX">
      When the user agent is to <dfn>start monitoring for changes to
      presentation display availability</dfn>, it must run the following steps:
    </p>
    <p>
      When a new <span data-anolis-spec="w3c-html" title="event handlers">event
      handler</span> <em>E</em> is added to
      <code><span>NavigatorPresentation</span>.onavailablechange</code>, the
      user agent must run the
    </p><a href="monitor-availability-algorithm">algorithm to monitor
    availability</a>.
    <p class="note">
      The mechanism used to monitor <a href="#presentation-display">presention
      displays</a> availability is left to the user agent. The user agent may
      choose search for screens at any time, not just when event handlers are
      added to <code>NavigatorPresentation.onavailablechange</code>.
    </p>
    <p class="open-issue">
      Do we want to fire the event at all handlers, or only the newly added
      one?
    </p>
    <p class="XXX">
      When the user agent is to <dfn>stop monitoring for changes to
      presentation display availability</dfn>, it must run the following steps:
    </p>
    <p>
      When the last <span data-anolis-spec="w3c-html" title=
      "event handlers">event handler</span> is removed from
      <code>NavigatorPresentation.onavailablechange</code>, the user agent may
      run the following steps:
    </p>
    <ol>
      <li>Cancel the <a href="monitor-availability-algorithm">algorithm to
      monitor availability change.</a>
      </li>
    </ol>
    <p class="XXX">
      When the user agent is required to <dfn>monitor presentation display
      availability</dfn>, it must run the following steps ...
    </p>
    <p>
      While there are <span data-anolis-spec="w3c-html">event handlers</span>
      added to NavigatorPresentation.onavailablechange, the user agent must
      continuously keep track of the available
    </p><a href="#presentation-display">presentation displays</a> and repeat
    the following steps:
    <ol>
      <li>
        <span data-anolis-spec="w3c-html">Queue a task</span> to retrieve the
        the list of curently available <a href=
        "#presentation-display">presentation displays</a> and let <a id=
        "newdisplays"><em>newDisplays</em></a> be this list.
      </li>
      <li>Wait for the completion of that task.
      </li>
      <li>If <a href="#availabledisplays">availableDisplays</a> is empty and
      <a href="#newdisplays">newDisplays</a> is not empty, then
        <ol>
          <li>
            <span data-anolis-spec="w3c-html">Queue a task</span> to
            <span data-anolis-spec="w3c-html" title="concept-event-fire">fire
            an event</span> named <code>availablechange</code> at <em>E</em>
            (and only <em>E</em>) with the event's <code>available</code>
            property set to <code>true</code>.
          </li>
        </ol>
      </li>
      <li>If <a href="#availabledisplays">availableDisplays</a> is not empty
      and <a href="#newdisplays">newDisplays</a> is empty, then:
        <div style="margin-left: 2em">
          <span data-anolis-spec="w3c-html">Queue a task</span> to
          <span data-anolis-spec="w3c-html" title="concept-event-fire">fire an
          event</span> named <code>availablechange</code> at <em>E</em> (and
          only <em>E</em>) with the event's <code>available</code> property set
          to <code>false</code>.
        </div>
      </li>
      <li>Set <a href="#availableDisplays">availableDisplays</a> to the value
      of <a href="#newDisplays">newDisplays</a>.
      </li>
    </ol>
    <h3>
      TODO
    </h3>
    <p class="open-issue">
      Need algorithm for receive message
    </p>
    <p class="open-issue">
      Need algorithm for initialization of the presented document
    </p>
    <p class="open-issue">
      We could write this spec in a way that distinguished the state of the
      presentation (owned by the user agent) from the state of the
      PresentationSession (owned by a specific document); however these should
      always be sync and it would likely result in more confusion than clarity.
    </p>
    <h2 class="no-num">
      References
    </h2>
    <div id="anolis-references"></div>
    <h2 class="no-num">
      Acknowledgments
    </h2>
    <p>
      Thanks to Wayne Carr, Louay Bassbous, Anssi Kostiainen, 闵洪波 (Hongbo Min),
      Anton Vayvod, and Mark Foltz for help with editing, reviews and feedback
      to this draft.
    </p>
  </body>
</html>
